// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "OI.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "SmartDashboard/SmartDashboard.h"
#include "Commands/AutonomousCommand.h"
#include "Commands/DriveWithJoysticks.h"
#include "Commands/CenterOnTote.h"
#include "Commands/WinchUpDown.h"
#include <DriverStation.h>
#include <sstream>
#include <string>



    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

OI::OI() {
	// Process operator interface input here.
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

	m_gamepad = new Joystick(2);
	
	m_rightJoystick = new Joystick(1);
	
	//m_rightJoystick->SetAxisChannel(Joystick::kTwistAxis, 3);

	m_leftJoystick = new Joystick(0);
	
	m_launchPad = new Joystick(3);

	/*
		 *  1 -- X
			2 -- A
			3 -- B
			4 -- Y
			5 -- LB
			6 -- RB
		 	7 -- LT
			8 -- RT
		 */

	// Button initialization
	m_rightButton10 = new JoystickButton(m_rightJoystick, 10);

	m_gamePadButtonA = new JoystickButton(m_gamepad, 2);
	m_gamePadButtonY = new JoystickButton(m_gamepad, 4);
	m_gamePadButtonX = new JoystickButton(m_gamepad, 3);

	// Button use
	m_rightButton10->WhenPressed(new CenterOnTote());

	m_gamePadButtonA->WhileHeld(new WinchUpDown(false, 0.2, 0.3));
	m_gamePadButtonY->WhileHeld(new WinchUpDown(true, 0.2, 1.0));
	m_gamePadButtonX->WhileHeld(new WinchUpDown(true, 0.2, 0.3));


     

        // SmartDashboard Buttons
	SmartDashboard::PutData("Autonomous Command", new AutonomousCommand());

	SmartDashboard::PutData("DriveWithJoysticks", new DriveWithJoysticks());


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
}

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=FUNCTIONS

/*Joystick* OI::getm_gamepad() {
	return m_gamepad;
}*/

Joystick* OI::getm_rightJoystick() {
	return m_rightJoystick;
}

Joystick* OI::getm_leftJoystick() {
	return m_leftJoystick;
}


//Launch pad Buttons and Indicators

int OI::GetElevatorPower() {
	float elevatorPower = 0;

	elevatorPower = m_launchPad->GetX();
	//elevatorPower = elevatorPower - .011;
	elevatorPower = elevatorPower + 1;
	elevatorPower = elevatorPower/2;
	elevatorPower = elevatorPower * 100;

	return static_cast<int>(elevatorPower);
}

void OI::SetLEDState(bool value) {
	m_launchPad->SetOutput(LAUNCHPAD_LED_INDICATOR, value);
}

std::string OI::NumberToStringElevatorPower() {
	std::ostringstream power;		//output string stream
	power << "Power = " << GetElevatorPower();	//use the string stream just like cout,except the stream prints not to stdout but to a string.
	std::string powerToString = power.str(); //the str() function of the stream returns the string.

	return powerToString;
}

void OI::PrintElevatorPowerValue() {
	SmartDashboard::PutString("DB/String 0", NumberToStringElevatorPower());
}

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=FUNCTIONS
